<!DOCTYPE html>
<!-- This file implements JavaScript-generated SVG elements for generating the
  - MIDI Minutes logo.  It also implements controls for adjusting aspects of
  - the logo for logo design purposes.
  -->
<html>
<head>
  <style type="text/css">
    .param-control {
      display: flex;
    }
    input[type=range] {
      vertical-align: middle;
      flex: 1;
    }
    input[type=number] {
      width: 7ch;
      vertical-align: middle;
    }
    input[type=color] {
      width: calc(7ch - 0.3ch);
      vertical-align: middle;
    }
    #run-clock-button {
      width: 3rem;
    }
    .gradstops-button {
      width: 3ch;
      margin: 1px;
    }
    .gradstops-header {
      display: flex;
    }
    .gradstops-label-text {
      display: inline-block;
      width: 8rem;
      font-weight: bold;
      vertical-align: middle;
      text-align: right;
      margin-right: 0.5rem;
    }
    .param-label-text {
      display: inline-block;
      width: 8rem;
      vertical-align: middle;
      text-align: right;
      margin-right: 0.5rem;
    }
    .pad {
      display: inline-block;
      width: 2rem;
      vertical-align: middle;
    }
    .slider-min,
    .slider-max {
      display: inline-block;
      vertical-align: middle; /* no effect in flexbox :( */
      margin: 0.1rem; /* setting a small margin helps vertial alignment */
    }
    .slider-min {
      width: 4ch;
      text-align: right;
    }
    .slider-max {
      width: 4ch;
      text-align: left;
    }
    body {
      margin: 1px;
    }
    .wrapper {
      display: flex;
      height: calc(100vh - 10px);
    }
    .wrapper .config {
      flex: 1;
      overflow: auto;
      min-width: 25rem;
    }
    .param-group-control {
      border: 1.2px solid gray;
      border-bottom-width: 0.6px;
      border-top-width: 0.6px;
      padding: 0.2rem;
    }
    .param-group-header {
      font-weight: bold;
    }
    .logo-wrapper {
      position: relative; /* Allow putting the resize tab over the logo */
      box-sizing: border-box;
    }
    .wrapper .logo-and-json {
      padding: 2px;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 10px);
      max-height: calc(100vh - 10px);
    }
    #logo {
      padding: 2px;
      max-height: 100%;
      max-width: 100%;
      vertical-align: top;
    }
    .resize-tab {
      width: 20px;
      height: 20px;
      position: absolute;
      right: 0px;
      bottom: 0px;
      cursor: nwse-resize;
    }
    #params-json {
      flex: 1;
      overflow: auto;
      min-height: 2rem;
      font-family: monospace;
      white-space: pre-wrap;
    }
  </style>

  <script type="text/javascript" defer>
    // Control configuration
    var config = {
      size: {step: 1, min: 4, max: 1400},
      radius: {step: 0.1, min: 0, max: 100},
      stroke: {step: 0.1, min: 0, max: 10},
      width: {step: 0.1, min: 0, max: 50},
      octaves: {step: 1, min: 1, max: 10},
      startkey: {step: 1, min: 1, max: 7},
      angle: {step: 1, min: 0, max: 360},
      offset: {step: 1, min: 0, max: 100},
      opacity: {step: 1, min: 0, max: 100},
      interval: {step: 1, min: 25, max: 1000},
    };

    // Slider-controlled logo parameters
    // Names are split with _ and the final element is looked up in the config
    // object to determine additional properties for the input controls.
    var params = {
      clock_face: {
        size: 200,
        fill_color: "#FFFFFF",
        inner_radius: 8,
        outer_radius: 98,
        octaves: 5,
        stroke: 2,
        ticks_angle: 0,
        piano_angle: 0,
        ms_interval: 1000,
      },
      hour_ticks: {
        color: "#000000",
        inner_width: 4,
        inner_radius: 88,
        middle_width: 4,
        middle_radius: 97.5,
        outer_width: 2,
        outer_radius: 98,
      },
      minute_ticks: {
        color: "#000000",
        inner_width: 3,
        inner_radius: 93,
        middle_width: 3,
        middle_radius: 97.5,
        outer_width: 2,
        outer_radius: 98,
      },
      hour_hand: {
        color: "black",
        inner_width: 0,
        inner_radius: 5,
        middle_width: 9,
        middle_radius: 20,
        outer_width: 0,
        outer_radius: 65,
        angle: 0,
      },
      minute_hand: {
        color: "black",
        inner_width: 0,
        inner_radius: 5,
        middle_width: 4,
        middle_radius: 20,
        outer_width: 0,
        outer_radius: 93,
        angle: 150,
      },
      second_hand: {
        color: "#FF0000",
        inner_width: 1.5,
        inner_radius: 5,
        outer_width: 1.5,
        outer_radius: 94,
        angle: 200,
      },
      black_keys: {
        color: "black",
        inner_width: 6.8,
        inner_radius: 60,
        outer_width: 9.9,
        outer_radius: 85,
        gradstops: [
          {offset: 0, opacity: 100, color: "#000000"},
          {offset: 100, opacity: 0, color: "#000000"},
        ],
      },
      white_keys: {
        color: "black",
        inner_width: 2,
        inner_radius: 40,
        outer_width: 2,
        outer_radius: 85,
        stroke: 2,
        gradstops: [
          {offset: 0, opacity: 100, color: "#000000"},
          {offset: 100, opacity: 0, color: "#000000"},
        ],
      },
    };

    var redraw = {
      clock_face: {
        size: function(e) {
          const s = params.clock_face.size;
          var el = document.getElementById('logo');
          el.setAttribute('width', s);
          el.setAttribute('height', s);
        },

        octaves: redraw_piano,
        piano_angle: function(e) {
          rotate_element(document.getElementById('piano-keys'), params.clock_face.piano_angle);
        },
        ticks_angle: function(e) {
          rotate_element(document.getElementById('clock-ticks'), params.clock_face.ticks_angle);
        },

        _else: function(e) {
          var outer_circle = document.getElementById('outer-circle');
          outer_circle.setAttribute("r", params.clock_face.outer_radius);
          outer_circle.setAttribute("stroke-width", params.clock_face.stroke);

          var inner_circle = document.getElementById('inner-circle');
          inner_circle.setAttribute("r", params.clock_face.inner_radius);

          var clock_face = document.getElementById('clock-face');
          clock_face.setAttribute("r", params.clock_face.outer_radius);
          clock_face.setAttribute("fill", params.clock_face.fill_color);
        },
      },
      hour_ticks: e => shape_ticks('hour-ticks', params.hour_ticks),
      minute_ticks: e => shape_ticks('minute-ticks', params.minute_ticks),
      hour_hand:   e => redraw_hand(document.getElementById('hour-hand'), params.hour_hand),
      minute_hand: e => redraw_hand(document.getElementById('minute-hand'), params.minute_hand),
      second_hand: e => redraw_hand(document.getElementById('second-hand'), params.second_hand),
      white_keys: e => shape_white_keys(),
      black_keys: e => shape_black_keys(),
    };

    function redraw_piano() {
      // Remove the keys elements and set them up again.
      remove_piano();
      construct_piano();
      shape_white_keys();
      shape_black_keys();
    }

    function shape_white_keys() {
      const g = params.white_keys;

      var white_key_group = document.getElementById('white-key-group');
      var white_keys = white_key_group.children;
      for (let i = 0; i < white_keys.length; i++) {
        key = white_keys[i];
        draw_hand(key, g);
      }

      var white_keycap_group = document.getElementById('white-keycap-group');
      white_keycap_group.setAttribute('transform', `scale(${g.inner_radius})`);
      white_keycap_group.setAttribute('stroke-width', g.stroke / 100);
      white_keycap_group.setAttribute('stroke', g.color);
    }

    function shape_black_keys() {
      var black_key_group = document.getElementById('black-key-group');
      var black_keys = black_key_group.children;
      const g = params.black_keys;
      for (let i = 0; i < black_keys.length; i++) {
        key = black_keys[i];
        draw_hand(key, g);
      }
    }

    function shape_ticks(ticks_id, g) {
      var ticks_group = document.getElementById(ticks_id);
      var ticks = ticks_group.children;
      for (let i = 0; i < ticks.length; i++) {
        draw_hand(ticks[i], g);
      }
    }

    function redraw_hand(hand, g) {
      draw_hand(hand, g);
      rotate_element(hand, g.angle);
    }

    function draw_hand(hand, g) {
      hand.setAttribute('fill', g.color);
      hand.setAttribute('points',
        `${g.inner_radius},${g.inner_width / 2}
         ${g.middle_radius ? `${g.middle_radius},${g.middle_width / 2}` : ''}
         ${g.outer_radius},${g.outer_width / 2}
         ${g.outer_radius},${-(g.outer_width / 2)}
         ${g.middle_radius ? `${g.middle_radius},${-(g.middle_width / 2)}` : ''}
         ${g.inner_radius},${-(g.inner_width / 2)}
        `);
    }

    // Generate a transform on the given SVG element that will
    // rotate it to the parameter settings in the given group.
    // The SVG element is assumed to be drawn along the X axis,
    // to the right.
    // The rotation is taken from the angle parameter.
    function rotate_element(el, angle) {
      el.setAttribute("transform", `rotate(${angle - 90})`);
    }

    function update_sibling(e) {
      var el = e.target;
      if ("other" in el) {
        el.other.value = el.value;
      }
    }

    // Return a phrase from the given - or _ separated identifier
    function wordify_ident(ident) {
      ident = ident.replace(/[-_]/g, ' ');
      ident = ident.replace(/\b\w/g, c => c.toUpperCase());
      return ident;
    }

    // Handle nested objects according to a path list.
    // Inspired by https://stackoverflow.com/a/22129960
    function getPropByPath(o, path) {
      return path.reduce((prev, cur) => prev && prev[cur], o);
    }
    function setPropByPath(o, path, value) {
      return path.reduce((prev, curr, i) => {
        return (i + 1 == path.length)
          ? prev[curr] = value
          : prev[curr] = prev[curr] || {};
      }, o);
    }

    function add_pad(el) {
      var pad = document.createElement('span');
      el.appendChild(pad);
      pad.setAttribute('class', 'pad');
    }

    function create_control_div(control_type, label, ...path) {
      var path_str = path.join('-');

      var param_div = document.createElement('div');
      param_div.id = `${path_str}-control`;
      param_div.setAttribute('class', 'param-control');

      // The label also contains all linked input elements, allowing one to
      // click anywhere on the control line to focus the main input
      // (for sliders, this is the number box)
      var param_label = document.createElement('label');
      param_div.appendChild(param_label);
      param_label.setAttribute('class', 'param-label');


      var param_label_span = document.createElement('span');
      param_label.appendChild(param_label_span);
      param_label_span.setAttribute('class', 'param-label-span');


      var span = document.createElement('span');
      param_label_span.appendChild(span);
      span.setAttribute('class', 'param-label-text');
      span.textContent = label;

      // Add an input of the given type to the param control's label
      function add_input_el(type, updater) {
        var el = document.createElement('input');

        el.type = type;
        el.id = `${path_str}-${type}`;
        el.value = getPropByPath(params, path);
        el.addEventListener("input", updater);

        for (const attr in config[control_type]) {
          el.setAttribute(attr, config[control_type][attr]);
        }
        return el;
      }

      // Add min or max <span> to a slider's <label> contents
      function add_slider_limit(attr) {
        var el = document.createElement('span');

        el.id = `${path_str}-${attr}`;
        el.setAttribute('class', `slider-${attr}`);
        el.textContent = config[control_type][attr];
        return el;
      }

      // Main <input> callback for input events
      function update_param(e) {
        const value = e.target.value;
        setPropByPath(params, path, value);
        showParamsJson();
        // dispatch the update to the associated SVG updater
        var curprop = redraw;
        for (const pathidx in path) {
          let pathbit = path[pathidx];
          if (!(pathbit in curprop)) {
            pathbit = "_else";
          }
          let nextprop = curprop[pathbit];
          if (typeof nextprop === "function") {
            // We found a redraw function - call it and stop the search
            nextprop(e);
            break;
          } else {
            // Descend to the next path-element depth in the redraw structure
            curprop = nextprop;
          }
        }
      }

      // The <input> element to target with this control's label via its
      // "for" attribute.  This element is also used to generate the
      // synthetic "input" event to initialize the generated SVG and JSON.
      let main_input;

      if (control_type == 'color') {
        main_input = param_label_span.appendChild(add_input_el('color', update_param));

      } else {
        // Link the range and number box inputs for the slider
        function update_slider(e) {
          update_sibling(e);
          update_param(e);
        }

        main_input = add_input_el('number', update_slider);
        other_input = add_input_el('range', update_slider);
        main_input.other = other_input;
        other_input.other = main_input;
        if (control_type == 'size') {
          main_input.addEventListener("change", resquare_logo);
          other_input.addEventListener("change", resquare_logo);
        }

        param_div.appendChild(main_input);
        param_div.appendChild(add_slider_limit('min'));
        param_div.appendChild(other_input);
        param_div.appendChild(add_slider_limit('max'));
      }

      param_label.setAttribute('for', main_input.id);
      main_input.dispatchEvent(new Event("input"));

      return param_div;
    }

    function create_gradstops(...path) {
      var stops_div = document.createElement('div');
      stops_div.id = path.join('-');
      stops_div.setAttribute('class', 'gradstops');

      var span = document.createElement('span');
      stops_div.appendChild(span);
      span.id = path.join('-');
      span.setAttribute('class', 'gradstops-header');

      var label_text = document.createElement('span');
      span.appendChild(label_text);
      label_text.setAttribute('class', 'gradstops-label-text');
      label_text.textContent = `Gradient Stops`;

      var stoplist = getPropByPath(params, path);
      for (const stopidx in stoplist) {
        add_gradstop_controls(stopidx);
      }

      function add_gradstop_controls(stopidx) {
        var stop_controls_div = document.createElement('div');
        stops_div.appendChild(stop_controls_div);
        stop_controls_div.id = [...path, stopidx].join('-');
        stop_controls_div.setAttribute('class', 'gradstop-controls');

        let gradstop = stoplist[stopidx];
        for (const control in gradstop) {
          let el = create_control_div(control, `stop${stopidx} ${wordify_ident(control)}`,
            ...path, stopidx, control);
          stop_controls_div.appendChild(el);
        }
      }

      var delstop_button = document.createElement('input');
      span.appendChild(delstop_button);
      delstop_button.type = 'button';
      delstop_button.id = `${stops_div.id}-del`;
      delstop_button.setAttribute('class', 'gradstops-button');
      delstop_button.value = "-";
      delstop_button.addEventListener('click', e => {
        if (stoplist.length > 2) {
          // Duplicate the last stop into the new one.
          // TODO - Recover stashed elements
          stoplist.pop(stoplist);
          stops_div.removeChild(stops_div.lastChild);
          showParamsJson();
        }
      });

      var addstop_button = document.createElement('input');
      span.appendChild(addstop_button);
      addstop_button.type = 'button';
      addstop_button.id = `${stops_div.id}-add`;
      addstop_button.setAttribute('class', 'gradstops-button');
      addstop_button.value = "+";
      addstop_button.addEventListener('click', e => {
        let new_stopidx = stoplist.length;
        // TODO - stash the removed elements
        stoplist.push({...stoplist[new_stopidx - 1]});
        add_gradstop_controls(new_stopidx);
      });

      return stops_div;
    }

    function add_controls_to_param_group(group, group_div) {
      for (const param in params[group]) {
        const control_type = param.replace(/.*_/, '');

        if (control_type == "gradstops") {
          let el = create_gradstops(group, param);
          group_div.appendChild(el);
        } else {
          let el = create_control_div(control_type, wordify_ident(param), group, param);
          group_div.appendChild(el);
        }

      }
    }

    function construct_param_controls() {
      var config_div = document.getElementById('config-control');

      for (const group in params) {
        var group_div = document.createElement('div');
        config_div.appendChild(group_div);
        group_div.id = group + '-control';
        group_div.setAttribute('class', 'param-group-control');

        var group_label = document.createElement('label');
        group_div.appendChild(group_label);
        group_label.textContent = wordify_ident(group);
        group_label.setAttribute('class', 'param-group-header');

        add_controls_to_param_group(group, group_div);
      }
    }

    function construct_ticks() {
      // Hour ticks
      var hour_ticks_el = document.getElementById('hour-ticks');
      for (let i = 0; i < 12; i++) {
        let tick = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
        hour_ticks_el.appendChild(tick);
        tick.id = `hour-tick-${i}`;
        rotate_element(tick, i * 360 / 12);
      }

      // Minute ticks
      var minute_ticks_el = document.getElementById('minute-ticks');
      for (let i = 0; i < 60; i++) {
        if (i % 5) {
          let tick = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
          minute_ticks_el.appendChild(tick);
          tick.id = `minute-tick-${i}`;
          rotate_element(tick, i * 360 / 60);
        }
      }
    }

    // when changing octaves, it's easiest just to delete all the keys and start over
    function remove_piano() {
      document.getElementById('white-key-group').textContent = '';
      document.getElementById('white-keycap-group').textContent = '';
      document.getElementById('black-key-group').textContent = '';
    }

    function construct_piano() {
      const octaves = params.clock_face.octaves;
      const octave_angle = (360.0 / octaves);
      const keys_per_octave = 12;
      const inner_key_angle = octave_angle / keys_per_octave;
      const white_keys_per_octave = 7;
      const white_key_angle = octave_angle / white_keys_per_octave;
      const black_keys_per_octave = 5;
      const white_key_ids = [0,2,4,5,7,9,11];
      const black_key_ids = [1,3,6,8,10];

      //  |                               ,
      //  |                            ,  |
      //  |                         ,     |\      r = d + s
      //  |                      ,        |~      h = r sin a
      //  |               r   ,           |a\     d = r cos a
      //  |                ,              |       s/h = h/d => s = h^2/d
      //  |             ,               h |  \
      //  |          ,                    |       s/r = (sin a)^2 / (cos a)
      //  |       ,                       |   \   normalize to r = 1
      //  |    ,                          |       s = (1 - cos(2*a)) / cos(a)
      //  | ,  )a = 1/2 key spread        |    \
      //  +-------------------------------+-----
      //   '--------------.--------------' '-.-'
      //                  d                  s
      let a = (white_key_angle * Math.PI / 180) / 2; // alpha
      let h = Math.sin(a);
      let d = Math.cos(a);

      // White Keys
      // These are implied by the cracks between the keys
      var white_key_group_el = document.getElementById('white-key-group');
      var white_keycap_group_el = document.getElementById('white-keycap-group');
      var black_key_group_el = document.getElementById('black-key-group');
      var num_white_keys = octaves * white_keys_per_octave;

      // These are special-cased because we need to align the cracks to the ticks
      for (let octave = 0; octave < octaves; octave++) {
        // white keys
        for (const key in white_key_ids) {
          // Construct the spaces between the keys
          let crack = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
          white_key_group_el.appendChild(crack);
          crack.id = `white-key-${octave}-${key}`;
          let angle = -90.0;
          angle += octave_angle * octave;
          angle += white_key_angle * key;
          crack.setAttribute("transform", `rotate(${angle})`);

          // Construct the key ends
          let end = document.createElementNS("http://www.w3.org/2000/svg", 'line');
          white_keycap_group_el.appendChild(end);
          end.id = `white-key-end-${octave}-${key}`;
          // This causes the stroke size to not even scale when scaling the whole svg!
          //end.setAttribute('vector-effect', 'non-scaling-stroke');
          end.setAttribute('transform', `rotate(${angle + white_key_angle / 2})`);
          end.setAttribute('x1', d);
          end.setAttribute('y1', -h);
          end.setAttribute('x2', d);
          end.setAttribute('y2', h);
        }

        // black keys
        let groupangle = white_key_angle * 3; // (3 white, 2 black)
        let numkeys = 5;
        let baseangle = 0;
        let key_id_offset = 0;
        for (const key_id in black_key_ids) {
          if (key_id == 2) {
            // Split evenly between the keys in the group of 4 whites
            baseangle = groupangle;
            groupangle = white_key_angle * 4; // (4 white, 3 black)
            numkeys = 7;
            key_id_offset = 2;
          }

          var bkey = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
          black_key_group_el.appendChild(bkey);
          bkey.id = `black-key-${key_id}`;

          let inner_key_angle = groupangle / numkeys;

          let angle = -90.0;
          angle += octave_angle * octave;
          angle += baseangle;
          angle += inner_key_angle * (((key_id - key_id_offset) * 2) + 1.5);
          bkey.setAttribute("transform", `rotate(${angle})`);
        }
      }
    }

    var exited_flat_logo_condition = false;

    // Set the logo size for a drag resize sequence.
    // Note the logo ends up constrained to a square since the redraw
    // function calls resquare_logo.
    function resize_logo(e, offsetX, offsetY) {
      var el = document.getElementById('logo');
      let sizeX = e.clientX - el.clientLeft + offsetX;
      let sizeY = e.clientY - el.clientTop + offsetY;

      var wrapper = document.getElementById('logo-wrapper');
      if (wrapper.scrollWidth > wrapper.scrollHeight && !exited_flat_logo_condition) {
        // Prevent odd jumping behavior when grabbing while flat
        sizeX = 0;
      } else {
        exited_flat_logo_condition = true;
      }

      const new_size = Math.min(Math.max(sizeX, sizeY, config.size.min), config.size.max);
      //console.log(`mouse: ${e.clientX},${e.clientY}; topleft: ${el.clientLeft},${el.clientTop}; offset: ${offsetX},${offsetY}, sizeXY: ${sizeX},${sizeY}, new_size: ${new_size}`);

      // trigger the redraw
      let main_input = document.getElementById("clock_face-size-number");
      main_input.value = new_size;
      main_input.dispatchEvent(new Event("input"));
    }

    // If the window or size are set such that the svg containing element
    // falls out of square, constrain the logo size so it fits into a square again.
    function resquare_logo() {
      var el = document.getElementById('logo');
      let actual_size = Math.min(el.scrollWidth, el.scrollHeight);
      if (actual_size < params.clock_face.size) {
        let main_input = document.getElementById("clock_face-size-number");
        main_input.value = actual_size;
        main_input.dispatchEvent(new Event("input"));
      }
    }

    // Adapted from the "improved makeResizableDiv" entry here:
    // https://medium.com/the-z/making-a-resizable-div-in-js-is-not-easy-as-you-think-bda19a1bc53d
    function make_resizable(el, resize) {
      // Offset from the lower right corner of the div containing the logo.
      // The mouse position plus this offset describes the intersection
      // of two bounding lines that constrain the logo
      var offsetX;
      var offsetY;

      el.addEventListener('mousedown', e => {
        // snap offsetX and offsetY - we want to keep the resize tab at this position
        // subtract from el.clientWidth and el.clientHeight to get offset into SVG
        offsetX = el.clientWidth - e.offsetX;
        offsetY = el.clientHeight - e.offsetY;
        //console.log("mousedown", e);
        exited_flat_logo_condition = false; // hack for resizing when tiny

        e.preventDefault();
        window.addEventListener('mousemove', drag_resize);
        window.addEventListener('mouseup', stop_resize);
      });

      function drag_resize(e) {
        resize(e, offsetX, offsetY);
      }

      function stop_resize(e) {
        window.removeEventListener('mousemove', drag_resize);
        window.removeEventListener('mouseup', stop_resize);
        resquare_logo();
      }
    }

    document.addEventListener("DOMContentLoaded", function() {
      construct_ticks();
      construct_piano();
      construct_param_controls();

      // hook up button actions
      function set_click_handler(id, fn) {
        document.getElementById(id).addEventListener("click", fn);
      }
      set_click_handler('save-svg-button', saveLogoSvg);
      set_click_handler('copy-params-button', copyParamsJson);
      set_click_handler('run-clock-button', toggleClockRun);

      // PianoClock logo resize support
      make_resizable(document.getElementById("logo-resizer"), resize_logo);
      window.addEventListener("resize", resquare_logo);
    });

    var interval_id = null;
    function toggleClockRun() {
      var button = document.getElementById('run-clock-button');
      if (interval_id === null) {
        // It's a clock!
        set_time();
        interval_id = window.setInterval(set_time, params.clock_face.ms_interval /*ms*/);
        button.value = "Stop!";
      } else {
        window.clearInterval(interval_id);
        interval_id = null;
        button.value = "Go!";
      }
    }

    function set_time() {
      // using trick from https://stackoverflow.com/a/10944417
      // to get ms since midnight
      const now = new Date();
      const then = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0);

      let s = (now.getTime() - then.getTime()) / 1000; // seconds since midnight
      if (params.clock_face.ms_interval == 1000) {
        s = Math.floor(s);
      }
      //console.log(s);
      set_hand("hour_hand-angle-number", s * 360 / 3600 / 12);
      set_hand("minute_hand-angle-number", s * 360 / 3600);
      set_hand("second_hand-angle-number", s * 360 / 60);

      function set_hand(id, angle) {
        let hour_number = document.getElementById(id);
        hour_number.value = angle % 360;
        hour_number.dispatchEvent(new Event("input"));
      }
    }

    // SVG saving code, modified from https://stackoverflow.com/a/46403589
    // To save as PNG, consider this: https://stackoverflow.com/a/44769098
    function saveSvg(svgEl, name) {
      svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");

      // Inject the json config used to generate the SVG
      var metadata_el = document.createElement('metadata');
      svgEl.insertBefore(metadata_el, svgEl.firstChild);
      var annotation_el = document.createElement('annotation');
      metadata_el.appendChild(annotation_el);
      annotation_el.textContent = showParamsJson();

      var svgData = svgEl.outerHTML;
      var preface = '<?xml version="1.0" standalone="no"?>\n';
      var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
      var svgUrl = URL.createObjectURL(svgBlob);
      var downloadLink = document.createElement("a");
      downloadLink.href = svgUrl;
      downloadLink.download = name;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);

      svgEl.removeChild(metadata_el);
    }

    function saveLogoSvg() {
      var logo = document.getElementById("logo");
      saveSvg(logo, "midi-minutes-logo.svg");
    }

    function showParamsJson() {
      var element = document.getElementById("params-json");
      text = JSON.stringify(params, null, 2);
      var lines = text.split("\n");

      function remove_quote (s) {
        return s.replace('"', '').replace('"', '');
      }
      lines = lines.map(remove_quote);
      text = lines.join("\n");

      element.textContent = text;
      return text;
    }

    function copyParamsJson() {
      var text = showParamsJson();
      // Add 4 spaces to each line before putting it in the clipboard
      var old_lines = text.split("\n");
      var lines = [];
      for (const line in old_lines) {
        lines.push(`    ${old_lines[line]}\n`);
      }
      window.prompt("Copy to clipboard: Ctrl+C, Enter", lines.join(""));
    }
  </script>
</head>

<body>

<div class="wrapper">
  <div class="logo-and-json">
    <div class="logo-wrapper" id="logo-wrapper">
      <svg id="logo"
          width="201" height="201" viewBox="-100 -100 200 200">
        <defs>
          <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="red" stop-opacity="1" />
            <stop offset="100%" stop-color="green" stop-opacity="1" />
          </linearGradient>
        </defs>

        <circle id="clock-face" cx="0" cy="0" r="40" stroke-width="0" />

        <g id="piano-keys">
          <g id="white-key-group"
             fill="url(#grad1)" stroke-opacity="1" stroke-width="0" stroke="blue" >
          </g>

          <g id="white-keycap-group"
             fill="url(#grad1)" stroke-opacity="1" stroke-width="3" stroke="blue" >
          </g>

          <g id="black-key-group"
             fill="url(#grad1)" stroke-opacity="1" stroke-width="0" stroke="blue" >
          </g>
        </g>

        <g id="clock-ticks">
          <g id="hour-ticks" stroke-width="0"> </g>
          <g id="minute-ticks" stroke-width="0"> </g>
        </g>

        <circle id="outer-circle" cx="0" cy="0" r="40" fill="none" stroke="black" stroke-width="4" />

        <g id="hands" stroke-width="0">
          <polygon id="hour-hand" />
          <polygon id="minute-hand" />
          <polygon id="second-hand" />
        </g>

        <circle id="inner-circle" cx="0" cy="0" r="4" stroke-width="0" />
      </svg>

      <svg id="logo-resizer" class="resize-tab" viewBox="0 0 100 100">
        <polygon id="tab-triangle"
                 points="0,100 100,0 100,100"
                 stroke="0"
                 fill="gray" />
      </svg>
    </div>

    <!-- Scaled version - obsolete now that we can adjust size
    <br />
    <svg id="logo-big" class="logo-scaled"
        xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
        width="400" height="400" viewBox="0 0 200 200">
      <use xlink:href="#logo" />
    </svg>
    -->

    <div>
      <input type="button" id="save-svg-button" value="Save to SVG" />
      <input type="button" id="copy-params-button" value="Copy JSON" />
      <input type="button" id="run-clock-button" value="Go" />
    </div>
    <div id="params-json"> </div>
  </div>

  <div class="config" id="config-control">
  </div>
</div>

</body>
</html>
