<!DOCTYPE html>
<!-- This file implements JavaScript-generated SVG elements for generating the
  - MIDI Minutes logo.  It also implements controls for adjusting aspects of
  - the logo for logo design purposes.
  -->
<html>
<head>
  <style type="text/css">
    .param-control {
      display: flex;
    }
    input[type=range] {
      vertical-align: middle;
      flex: 1;
    }
    input[type=number] {
      width: 6ch;
      vertical-align: middle;
    }
    input[type=color] {
      width: calc(6ch - 0.3ch);
      vertical-align: middle;
    }
    .gradstops-button {
      width: 3ch;
      margin: 1px;
    }
    .gradstops-header {
      display: flex;
    }
    .gradstops-label-text {
      display: inline-block;
      width: 8rem;
      font-weight: bold;
      vertical-align: middle;
      text-align: right;
      margin-right: 0.5rem;
    }
    .param-label-text {
      display: inline-block;
      width: 8rem;
      vertical-align: middle;
      text-align: right;
      margin-right: 0.5rem;
    }
    .pad {
      display: inline-block;
      width: 2rem;
      vertical-align: middle;
    }
    .slider-min,
    .slider-max {
      display: inline-block;
      vertical-align: middle; /* no effect in flexbox :( */
      margin: 0.1rem; /* setting a small margin helps vertial alignment */
    }
    .slider-min {
      width: 4ch;
      text-align: right;
    }
    .slider-max {
      width: 4ch;
      text-align: left;
    }
    body {
      margin: 1px;
    }
    .wrapper {
      display: flex;
      height: calc(100vh - 10px);
    }
    .wrapper .config {
      flex: 1;
      overflow: auto;
      min-width: 25rem;
    }
    .param-group-control {
      border: 1.2px solid gray;
      border-bottom-width: 0.6px;
      border-top-width: 0.6px;
      padding: 0.2rem;
    }
    .param-group-header {
      font-weight: bold;
    }
    .logo-wrapper {
      position: relative; /* Allow putting the resize tab over the logo */
      box-sizing: border-box;
    }
    .wrapper .logo-and-json {
      padding: 2px;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 10px);
      max-height: calc(100vh - 10px);
    }
    #logo {
      padding: 2px;
      max-height: 100%;
      max-width: 100%;
      vertical-align: top;
    }
    .resize-tab {
      width: 20px;
      height: 20px;
      position: absolute;
      right: 0px;
      bottom: 0px;
      cursor: nwse-resize;
    }
    #params-json {
      flex: 1;
      overflow: auto;
      min-height: 2rem;
      font-family: monospace;
      white-space: pre-wrap;
    }
  </style>

  <script type="text/javascript" defer>
    // Control configuration
    var config = {
      size: {step: 1, min: 4, max: 1400},
      radius: {step: 0.1, min: 0, max: 100},
      stroke: {step: 0.1, min: 0, max: 10},
      width: {step: 0.1, min: 0, max: 50},
      octaves: {step: 1, min: 1, max: 10},
      startkey: {step: 1, min: 1, max: 7},
      hours: {step: 1, min: 0, max: 12},
      minutes: {step: 1, min: 0, max: 60},
      seconds: {step: 1, min: -60, max: 60},
      offset: {step: 1, min: 0, max: 100},
      opacity: {step: 1, min: 0, max: 100},
    };

    // Slider-controlled logo parameters
    // Names are split with _ and the final element is looked up in the config
    // object to determine additional properties for the input controls.
    var params = {
      clock_face: {
        size: 200,
        fill_color: "#FFFFFF",
        inner_radius: 8,
        outer_radius: 98,
        octaves: 5,
        stroke: 2,
      },
      minute_ticks: {
        color: "#000000",
        inner_width: 3,
        inner_radius: 93,
        middle_width: 3,
        middle_radius: 97.5,
        outer_width: 2,
        outer_radius: 98,
      },
      hour_ticks: {
        color: "#000000",
        inner_width: 4,
        inner_radius: 88,
        middle_width: 4,
        middle_radius: 97.5,
        outer_width: 2,
        outer_radius: 98,
      },
      minute_hand: {
        color: "black",
        inner_width: 0,
        inner_radius: 5,
        middle_width: 4,
        middle_radius: 20,
        outer_width: 0,
        outer_radius: 95,
        minutes: 25,
        seconds: 0,
      },
      hour_hand: {
        color: "black",
        inner_width: 0,
        inner_radius: 5,
        middle_width: 9,
        middle_radius: 20,
        outer_width: 0,
        outer_radius: 65,
        hours: 0,
        minutes: 0,
        seconds: 0,
      },
      black_keys: {
        color: "black",
        inner_width: 6.8,
        inner_radius: 60,
        outer_width: 9.9,
        outer_radius: 85,
        minutes: 0,
        seconds: 0,
        gradstops: [
          {offset: 0, opacity: 100, color: "#000000"},
          {offset: 100, opacity: 0, color: "#000000"},
        ],
      },
      white_keys: {
        color: "black",
        inner_width: 2,
        inner_radius: 40,
        outer_width: 2,
        outer_radius: 85,
        stroke: 2,
        minutes: 0,
        seconds: 0,
        gradstops: [
          {offset: 0, opacity: 100, color: "#000000"},
          {offset: 100, opacity: 0, color: "#000000"},
        ],
      },
    };

    var redraw = {
      clock_face: {
        size: function(e) {
          const s = params.clock_face.size;
          var el = document.getElementById('logo');
          el.setAttribute('width', s);
          el.setAttribute('height', s);
        },

        octaves: function(e) {
          // Remove the keys elements and set them up again.
          remove_piano();
          construct_piano();
          shape_white_keys();
          shape_black_keys();
        },

        _else: function(e) {
          var outer_circle = document.getElementById('outer-circle');
          outer_circle.setAttribute("r", params.clock_face.outer_radius);
          outer_circle.setAttribute("fill", params.clock_face.fill_color);

          var inner_circle = document.getElementById('inner-circle');
          inner_circle.setAttribute("r", params.clock_face.inner_radius);
        },
      },
      hour_ticks: e => shape_ticks('hour-ticks', params.hour_ticks),
      minute_ticks: e => shape_ticks('minute-ticks', params.minute_ticks),
      minute_hand: e => redraw_hand(document.getElementById('minute-hand'), params.minute_hand),
      hour_hand:   e => redraw_hand(document.getElementById('hour-hand'), params.hour_hand),
      white_keys: e => shape_white_keys(),
      black_keys: e => shape_black_keys(),
    };

    function shape_white_keys() {
      var white_key_group = document.getElementById('white-key-group');
      var white_keys = white_key_group.children;
      const g = params.white_keys;
      for (let i = 0; i < white_keys.length; i++) {
        key = white_keys[i];
        draw_hand(key, g);
      }
    }

    function shape_black_keys() {
      var black_key_group = document.getElementById('black-key-group');
      var black_keys = black_key_group.children;
      const g = params.black_keys;
      for (let i = 0; i < black_keys.length; i++) {
        key = black_keys[i];
        draw_hand(key, g);
      }
    }

    function shape_ticks(ticks_id, g) {
      var ticks_group = document.getElementById(ticks_id);
      var ticks = ticks_group.children;
      for (let i = 0; i < ticks.length; i++) {
        draw_hand(ticks[i], g);
      }
    }

    function redraw_hand(hand, g) {
      draw_hand(hand, g);
      rotate_hand(hand, g);
    }

    function draw_hand(hand, g) {
      hand.setAttribute('fill', g.color);
      hand.setAttribute('points',
        `${g.inner_radius},${g.inner_width / 2}
         ${g.middle_radius ? `${g.middle_radius},${g.middle_width / 2}` : ''}
         ${g.outer_radius},${g.outer_width / 2}
         ${g.outer_radius},${-(g.outer_width / 2)}
         ${g.middle_radius ? `${g.middle_radius},${-(g.middle_width / 2)}` : ''}
         ${g.inner_radius},${-(g.inner_width / 2)}
        `);
    }

    // Generate a transform on the given SVG element that will
    // rotate it to the parameter settings in the given group.
    // The SVG element is assumed to be drawn along the X axis,
    // to the right.
    // The rotation is taken from the hours, minutes, and seconds
    // parameters in the param group.
    // * hours: moves 1/12th of the circle (30 degrees)
    // * minutes: moves 1/60th of the circle (6 degrees)
    // * seconds: moves 1/3600th of the circle (.1 degrees)
    function rotate_hand(el, g) {
      var angle = -90;
      if ('hours' in g) { angle += Number(g.hours) * 360 / 12; }
      if ('minutes' in g) { angle += Number(g.minutes) * 360 / 60; }
      if ('seconds' in g) { angle += Number(g.seconds) * 0.1 ; }
      el.setAttribute("transform", `rotate(${angle})`);
    }

    function update_sibling(e) {
      var el = e.target;
      if ("other" in el) {
        el.other.value = el.value;
      }
    }

    // Return a phrase from the given - or _ separated identifier
    function wordify_ident(ident) {
      ident = ident.replace(/[-_]/g, ' ');
      ident = ident.replace(/\b\w/g, c => c.toUpperCase());
      return ident;
    }

    // Handle nested objects according to a path list.
    // Inspired by https://stackoverflow.com/a/22129960
    function getPropByPath(o, path) {
      return path.reduce((prev, cur) => prev && prev[cur], o);
    }
    function setPropByPath(o, path, value) {
      return path.reduce((prev, curr, i) => {
        return (i + 1 == path.length)
          ? prev[curr] = value
          : prev[curr] = prev[curr] || {};
      }, o);
    }

    function add_pad(el) {
      var pad = document.createElement('span');
      el.appendChild(pad);
      pad.setAttribute('class', 'pad');
    }

    function create_control_div(control_type, label, ...path) {
      var path_str = path.join('-');

      var param_div = document.createElement('div');
      param_div.id = `${path_str}-control`;
      param_div.setAttribute('class', 'param-control');

      // The label also contains all linked input elements, allowing one to
      // click anywhere on the control line to focus the main input
      // (for sliders, this is the number box)
      var param_label = document.createElement('label');
      param_div.appendChild(param_label);
      param_label.setAttribute('class', 'param-label');


      var param_label_span = document.createElement('span');
      param_label.appendChild(param_label_span);
      param_label_span.setAttribute('class', 'param-label-span');


      var span = document.createElement('span');
      param_label_span.appendChild(span);
      span.setAttribute('class', 'param-label-text');
      span.textContent = label;

      // Add an input of the given type to the param control's label
      function add_input_el(type, updater) {
        var el = document.createElement('input');

        el.type = type;
        el.id = `${path_str}-${type}`;
        el.value = getPropByPath(params, path);
        el.addEventListener("input", updater);

        for (const attr in config[control_type]) {
          el.setAttribute(attr, config[control_type][attr]);
        }
        return el;
      }

      // Add min or max <span> to a slider's <label> contents
      function add_slider_limit(attr) {
        var el = document.createElement('span');

        el.id = `${path_str}-${attr}`;
        el.setAttribute('class', `slider-${attr}`);
        el.textContent = config[control_type][attr];
        return el;
      }

      // Main <input> callback for input events
      function update_param(e) {
        const value = e.target.value;
        setPropByPath(params, path, value);
        showParamsJson();
        // dispatch the update to the associated SVG updater
        var curprop = redraw;
        for (const pathidx in path) {
          let pathbit = path[pathidx];
          if (!(pathbit in curprop)) {
            pathbit = "_else";
          }
          let nextprop = curprop[pathbit];
          if (typeof nextprop === "function") {
            // We found a redraw function - call it and stop the search
            nextprop(e);
            break;
          } else {
            // Descend to the next path-element depth in the redraw structure
            curprop = nextprop;
          }
        }
      }

      // The <input> element to target with this control's label via its
      // "for" attribute.  This element is also used to generate the
      // synthetic "input" event to initialize the generated SVG and JSON.
      let main_input;

      if (control_type == 'color') {
        main_input = param_label_span.appendChild(add_input_el('color', update_param));

      } else {
        // Link the range and number box inputs for the slider
        function update_slider(e) {
          update_sibling(e);
          update_param(e);
        }

        main_input = add_input_el('number', update_slider);
        other_input = add_input_el('range', update_slider);
        main_input.other = other_input;
        other_input.other = main_input;
        if (control_type == 'size') {
          main_input.addEventListener("change", resquare_logo);
          other_input.addEventListener("change", resquare_logo);
        }

        param_div.appendChild(main_input);
        param_div.appendChild(add_slider_limit('min'));
        param_div.appendChild(other_input);
        param_div.appendChild(add_slider_limit('max'));
      }

      param_label.setAttribute('for', main_input.id);
      main_input.dispatchEvent(new Event("input"));

      return param_div;
    }

    function create_gradstops(...path) {
      var stops_div = document.createElement('div');
      stops_div.id = path.join('-');
      stops_div.setAttribute('class', 'gradstops');

      var span = document.createElement('span');
      stops_div.appendChild(span);
      span.id = path.join('-');
      span.setAttribute('class', 'gradstops-header');

      var label_text = document.createElement('span');
      span.appendChild(label_text);
      label_text.setAttribute('class', 'gradstops-label-text');
      label_text.textContent = `Gradient Stops`;

      var stoplist = getPropByPath(params, path);
      for (const stopidx in stoplist) {
        add_gradstop_controls(stopidx);
      }

      function add_gradstop_controls(stopidx) {
        var stop_controls_div = document.createElement('div');
        stops_div.appendChild(stop_controls_div);
        stop_controls_div.id = [...path, stopidx].join('-');
        stop_controls_div.setAttribute('class', 'gradstop-controls');

        let gradstop = stoplist[stopidx];
        for (const control in gradstop) {
          let el = create_control_div(control, `stop${stopidx} ${wordify_ident(control)}`,
            ...path, stopidx, control);
          stop_controls_div.appendChild(el);
        }
      }

      var delstop_button = document.createElement('input');
      span.appendChild(delstop_button);
      delstop_button.type = 'button';
      delstop_button.id = `${stops_div.id}-del`;
      delstop_button.setAttribute('class', 'gradstops-button');
      delstop_button.value = "-";
      delstop_button.addEventListener('click', e => {
        if (stoplist.length > 2) {
          // Duplicate the last stop into the new one.
          // TODO - Recover stashed elements
          stoplist.pop(stoplist);
          stops_div.removeChild(stops_div.lastChild);
          showParamsJson();
        }
      });

      var addstop_button = document.createElement('input');
      span.appendChild(addstop_button);
      addstop_button.type = 'button';
      addstop_button.id = `${stops_div.id}-add`;
      addstop_button.setAttribute('class', 'gradstops-button');
      addstop_button.value = "+";
      addstop_button.addEventListener('click', e => {
        let new_stopidx = stoplist.length;
        // TODO - stash the removed elements
        stoplist.push({...stoplist[new_stopidx - 1]});
        add_gradstop_controls(new_stopidx);
      });

      return stops_div;
    }

    function add_controls_to_param_group(group, group_div) {
      for (const param in params[group]) {
        const control_type = param.replace(/.*_/, '');

        if (control_type == "gradstops") {
          let el = create_gradstops(group, param);
          group_div.appendChild(el);
        } else {
          let el = create_control_div(control_type, wordify_ident(param), group, param);
          group_div.appendChild(el);
        }

      }
    }

    function construct_param_controls() {
      var config_div = document.getElementById('config-control');

      for (const group in params) {
        var group_div = document.createElement('div');
        config_div.appendChild(group_div);
        group_div.id = group + '-control';
        group_div.setAttribute('class', 'param-group-control');

        var group_label = document.createElement('label');
        group_div.appendChild(group_label);
        group_label.textContent = wordify_ident(group);
        group_label.setAttribute('class', 'param-group-header');

        add_controls_to_param_group(group, group_div);
      }
    }

    function construct_ticks() {
      // Hour ticks
      var hour_ticks_el = document.getElementById('hour-ticks');
      for (let i = 0; i < 12; i++) {
        let tick = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
        hour_ticks_el.appendChild(tick);
        tick.id = `hour-tick-${i}`;
        rotate_hand(tick, {hours: i});
      }

      // Minute ticks
      var minute_ticks_el = document.getElementById('minute-ticks');
      for (let i = 0; i < 60; i++) {
        if (i % 5) {
          let tick = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
          minute_ticks_el.appendChild(tick);
          tick.id = `minute-tick-${i}`;
          rotate_hand(tick, {minutes: i});
        }
      }
    }

    // when changing octaves, it's easiest just to delete all the keys and start over
    function remove_piano() {
      document.getElementById('white-key-group').textContent = '';
      document.getElementById('black-key-group').textContent = '';
    }

    function construct_piano() {
      const octaves = params.clock_face.octaves;
      const octave_angle = (360.0 / octaves);
      const keys_per_octave = 12;
      const inner_key_angle = octave_angle / keys_per_octave;
      const white_keys_per_octave = 7;
      const black_keys_per_octave = 5;
      const white_key_ids = [0,2,4,5,7,9,11];
      const black_key_ids = [1,3,6,8,10];
      const longcracks = [0, 5];
      const longcracks_end = [0, 5, 12];

      // White Keys
      // These are implied by the cracks between the keys
      var white_key_group_el = document.getElementById('white-key-group');
      var num_white_keys = octaves * white_keys_per_octave;
      // These are special-cased because we need to align the cracks to the ticks
      for (let octave = 0; octave < octaves; octave++) {
        let angles = [];
        for (let longcrack in longcracks) {
          let crack = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
          white_key_group_el.appendChild(crack);
          crack.id = `white-key-${octave}-${longcracks[longcrack]}`;
          let angle = -90.0;
          angle += octave_angle * octave;
          angle += inner_key_angle * longcracks[longcrack];
          crack.setAttribute("transform", `rotate(${angle})`);
          angles.push(angle);
        }

        angles.push(-90.0 + (octave_angle * (octave + 1)));
        for (let c in longcracks) {
          c = Number(c);
          let numcracks = Math.floor((longcracks_end[c+1] - longcracks_end[c]) / 2.0);
          let step_angle = (angles[c+1] - angles[c]) / (numcracks + 1.0);
          //console.log({c: c, longcracks_endc: longcracks_end[c+1], numcracks: numcracks, octave: octave, step_angle: step_angle});

          for (let i = 0; i < numcracks; i++) {
            let crack = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
            white_key_group_el.appendChild(crack);
            crack.id = `white-key-${octave}-${longcracks[c]}-${i}`;
            let angle = angles[c];
            angle += step_angle * (i+1);
            console.log({id: crack.id, i: i, octave: octave, angle: angle});
            crack.setAttribute("transform", `rotate(${angle})`);
          }
        }
      }

      // Black Keys
      var black_key_group_el = document.getElementById('black-key-group');
      // TODO If we want the octaves slider to work, we need to regenerate these on change
      var num_black_keys = octaves * black_keys_per_octave;
      for (let i = 0; i < num_black_keys; i++) {
        let key = document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
        black_key_group_el.appendChild(key);
        key.id = `black-key-${i}`;

        const octave = Math.floor(i / black_keys_per_octave);
        let angle = -90.0;
        // set the octave angle offset
        angle += octave_angle * octave;
        angle += inner_key_angle * black_key_ids[i % black_keys_per_octave];
        angle += inner_key_angle * 0.5; // align edge
        //console.log({bkey: i, octave: octave, octave_angle: octave_angle,
        //  inner_key_angle: inner_key_angle, angle: angle});
        key.setAttribute("transform", `rotate(${angle})`);
      }
    }

    var exited_flat_logo_condition = false;

    // Set the logo size for a drag resize sequence.
    // Note the logo ends up constrained to a square since the redraw
    // function calls resquare_logo.
    function resize_logo(e, offsetX, offsetY) {
      var el = document.getElementById('logo');
      let sizeX = e.clientX - el.clientLeft + offsetX;
      let sizeY = e.clientY - el.clientTop + offsetY;

      var wrapper = document.getElementById('logo-wrapper');
      if (wrapper.scrollWidth > wrapper.scrollHeight && !exited_flat_logo_condition) {
        // Prevent odd jumping behavior when grabbing while flat
        sizeX = 0;
      } else {
        exited_flat_logo_condition = true;
      }

      const new_size = Math.min(Math.max(sizeX, sizeY, config.size.min), config.size.max);
      //console.log(`mouse: ${e.clientX},${e.clientY}; topleft: ${el.clientLeft},${el.clientTop}; offset: ${offsetX},${offsetY}, sizeXY: ${sizeX},${sizeY}, new_size: ${new_size}`);

      // trigger the redraw
      let main_input = document.getElementById("clock_face-size-number");
      main_input.value = new_size;
      main_input.dispatchEvent(new Event("input"));
    }

    // If the window or size are set such that the svg containing element
    // falls out of square, constrain the logo size so it fits into a square again.
    function resquare_logo() {
      var el = document.getElementById('logo');
      let actual_size = Math.min(el.scrollWidth, el.scrollHeight);
      if (actual_size < params.clock_face.size) {
        let main_input = document.getElementById("clock_face-size-number");
        main_input.value = actual_size;
        main_input.dispatchEvent(new Event("input"));
      }
    }

    // Adapted from the "improved makeResizableDiv" entry here:
    // https://medium.com/the-z/making-a-resizable-div-in-js-is-not-easy-as-you-think-bda19a1bc53d
    function make_resizable(el, resize) {
      // Offset from the lower right corner of the div containing the logo.
      // The mouse position plus this offset describes the intersection
      // of two bounding lines that constrain the logo
      var offsetX;
      var offsetY;

      el.addEventListener('mousedown', e => {
        // snap offsetX and offsetY - we want to keep the resize tab at this position
        // subtract from el.clientWidth and el.clientHeight to get offset into SVG
        offsetX = el.clientWidth - e.offsetX;
        offsetY = el.clientHeight - e.offsetY;
        //console.log("mousedown", e);
        exited_flat_logo_condition = false; // hack for resizing when tiny

        e.preventDefault();
        window.addEventListener('mousemove', drag_resize);
        window.addEventListener('mouseup', stop_resize);
      });

      function drag_resize(e) {
        resize(e, offsetX, offsetY);
      }

      function stop_resize(e) {
        window.removeEventListener('mousemove', drag_resize);
        window.removeEventListener('mouseup', stop_resize);
        resquare_logo();
      }
    }

    document.addEventListener("DOMContentLoaded", function() {
      construct_ticks();
      construct_piano();
      construct_param_controls();

      // hook up button actions
      function set_click_handler(id, fn) {
        document.getElementById(id).addEventListener("click", fn);
      }
      set_click_handler('save-svg-button', saveLogoSvg);
      set_click_handler('copy-params-button', copyParamsJson);
      make_resizable(document.getElementById("logo-resizer"), resize_logo);
      window.addEventListener("resize", resquare_logo);
    });

    // SVG saving code, modified from https://stackoverflow.com/a/46403589
    // To save as PNG, consider this: https://stackoverflow.com/a/44769098
    function saveSvg(svgEl, name) {
      svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");

      // Inject the json config used to generate the SVG
      var metadata_el = document.createElement('metadata');
      svgEl.insertBefore(metadata_el, svgEl.firstChild);
      var annotation_el = document.createElement('annotation');
      metadata_el.appendChild(annotation_el);
      annotation_el.textContent = showParamsJson();

      var svgData = svgEl.outerHTML;
      var preface = '<?xml version="1.0" standalone="no"?>\n';
      var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
      var svgUrl = URL.createObjectURL(svgBlob);
      var downloadLink = document.createElement("a");
      downloadLink.href = svgUrl;
      downloadLink.download = name;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);

      svgEl.removeChild(metadata_el);
    }

    function saveLogoSvg() {
      var logo = document.getElementById("logo");
      saveSvg(logo, "midi-minutes-logo.svg");
    }

    function showParamsJson() {
      var element = document.getElementById("params-json");
      text = JSON.stringify(params, null, 2);
      var lines = text.split("\n");

      function remove_quote (s) {
        return s.replace('"', '').replace('"', '');
      }
      lines = lines.map(remove_quote);
      text = lines.join("\n");

      element.textContent = text;
      return text;
    }

    function copyParamsJson() {
      var text = showParamsJson();
      // Add 4 spaces to each line before putting it in the clipboard
      var old_lines = text.split("\n");
      var lines = [];
      for (const line in old_lines) {
        lines.push(`    ${old_lines[line]}\n`);
      }
      window.prompt("Copy to clipboard: Ctrl+C, Enter", lines.join(""));
    }
  </script>
</head>

<body>

<div class="wrapper">
  <div class="logo-and-json">
    <div class="logo-wrapper" id="logo-wrapper">
      <svg id="logo"
          width="201" height="201" viewBox="-100 -100 200 200">

        <g id="clock-face">
          <circle id="outer-circle" cx="0" cy="0" r="40" stroke="black" stroke-width="4" />
          <circle id="inner-circle" cx="0" cy="0" r="4" stroke-width="0" />
        </g>

        <g id="hour-ticks" stroke-width="0">
        </g>

        <g id="minute-ticks" stroke-width="0">
        </g>

        <g id="hands" stroke-width="0">
          <polygon id="minute-hand" />
          <polygon id="hour-hand" />
        </g>

        <!--
        <path d="M 0 20 l 0 20"
              stroke="black" fill="green" stroke-width="2" stroke-opacity="0.5"/>
              -->
        <defs>
          <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="red" stop-opacity="1" />
            <stop offset="100%" stop-color="green" stop-opacity="1" />
          </linearGradient>
        </defs>

        <g id="white-key-group"
           fill="url(#grad1)" stroke-opacity="1" stroke-width="4" stroke-color="blue" >
        </g>

        <g id="black-key-group"
           fill="url(#grad1)" stroke-opacity="1" stroke-width="4" stroke-color="blue" >
        </g>
        <!--path d="M 10 315
                 L 110 215
                 A 30 50 0 0 1 162.55 162.45
                 L 172.55 152.45
                 A 30 50 -45 0 1 215.1 109.9
                 L 315 10" stroke="black" fill="green" stroke-width="2" fill-opacity="0.5"/-->
      </svg>
      <svg id="logo-resizer" class="resize-tab" viewBox="0 0 100 100">
        <polygon id="tab-triangle"
                 points="0,100 100,0 100,100"
                 stroke="0"
                 fill="gray" />
      </svg>
    </div>

    <!-- Scaled version - obsolete now that we can adjust size
    <br />
    <svg id="logo-big" class="logo-scaled"
        xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
        width="400" height="400" viewBox="0 0 200 200">
      <use xlink:href="#logo" />
    </svg>
    -->

    <div>
      <input type="button" id="save-svg-button" value="Save to SVG" />
      <input type="button" id="copy-params-button" value="Copy JSON" />
    </div>
    <div id="params-json"> </div>
  </div>

  <div class="config" id="config-control">
  </div>
</div>

<!-- other svg examples from w3schools
<svg width="400" height="100">
  <rect width="400" height="100" style="fill:rgb(0,0,255);stroke-width:10;stroke:rgb(0,0,0)" />
</svg>
<br/>

<svg width="400" height="180">
  <rect x="50" y="20" rx="20" ry="20" width="150" height="150"
  style="fill:red;stroke:black;stroke-width:5;opacity:0.5" />
</svg>
<br/>

<svg width="300" height="200">
  <polygon points="100,10 40,198 190,78 10,78 160,198"
  style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;" />
</svg>
<br/>

<svg height="130" width="500">
  <defs>
    <linearGradient id="grad2" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="red" stop-opacity="1" />
      <stop offset="100%" stop-color="green" stop-opacity="1" />
    </linearGradient>
  </defs>
  <ellipse cx="100" cy="70" rx="85" ry="55" fill="url(#grad2)" />
  <text fill="#ffffff" font-size="45" font-family="Verdana" x="45" y="86">!SVG</text>
  Sorry, your browser does not support inline SVG.
</svg>
<br/>
-->

</body>
</html>
